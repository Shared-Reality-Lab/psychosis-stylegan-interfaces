<!DOCTYPE html>
<html lang='en'>
<head>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,600' rel='stylesheet'>
    <link rel='stylesheet' type='text/css' href='assets/css/style.css'>
    <link rel="stylesheet" type='text/css' href="assets/css/fontawesome.css">
    <title>Avatar Synthesis</title>
    <meta charset='utf-8'/>
</head>
<body>
<!-- version: 0.0.90 -->
<script type='x-shader/x-vertex' id='vertex-shader'>
    /**
    * The vertex shader's main() function must define `gl_Position`,
    * which describes the position of each vertex in screen coordinates.
    *
    * To do so, we can use the following variables defined by Three.js:
    *   uniform mat4 projectionMatrix - maps camera space into screen space
    *   uniform mat4 modelViewMatrix - combines:
    *     model matrix: maps a point's local coordinate space into world space
    *     view matrix: maps world space into camera space
    *
    * `attributes` can vary from vertex to vertex and are defined as arrays
    *   with length equal to the number of vertices. Each index in the array
    *   is an attribute for the corresponding vertex. Each attribute must
    *   contain n_vertices * n_components, where n_components is the length
    *   of the given datatype (e.g. for a vec2, n_components = 2; for a float,
    *   n_components = 1)
    * `uniforms` are constant across all vertices
    * `varyings` are values passed from the vertex to the fragment shader
    *
    * For the full list of uniforms defined by three, see:
    *   https://threejs.org/docs/#api/renderers/webgl/WebGLProgram
    **/

    #version 100
    #define SHADER_NAME instancedVertex
    #define SELECTING

    // set float precision
    precision mediump float;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform vec3 cameraPosition;
    uniform float scale;
    uniform float scaleTarget;
    uniform float transitionPercent;
    uniform float scaleTransitionPercent;
    uniform float borderWidth;
    uniform float delay;

    attribute vec3 pos0;          // x y z position offsets for an instance
    attribute vec3 pos1;          // x y z position to which we're transitioning
    attribute vec3 color;         // unique color for cell; used for raycasting
    attribute float width;        // px width of cell in lod texture
    attribute float height;       // px height of cell in lod texture
    attribute vec2 offset;        // px offset in tex from left, top
    attribute float opacity;      // opacity value for cell
    attribute float selected;     // 1 if the cell is selected else 0
    attribute float textureIndex; // index of an instance's texture among all textures

    varying vec3 vColor;          // cell color
    varying vec2 vOffset;         // px of cell offset left, top in texture
    varying float vWidth;         // px width of cell in lod texture
    varying float vHeight;        // px height of cell in lod texture
    varying float vOpacity;       // cell opacity
    varying float vSelected;      // 1 if this cell is selected else 0
    varying float vTextureIndex;  // cell texture idx (varyings can't be int)

    void main() {
      // pass varyings to fragment shader
      vTextureIndex = textureIndex;
      vColor = color;
      vWidth = width;
      vHeight = height;
      vOffset = offset;
      vOpacity = opacity;
      vSelected = selected;

      // determine how far this point has proceeded in its transition
      float delayX = (pos1.x + 1.0) / 2.0;
      float delayY = (pos0.y + 1.0) / 2.0;
      // pos0 has domains -1:1, so the delay sum above is <= 2.0
      float d = ((delayX + delayY) / 2.0) * delay;

      float percent = clamp(transitionPercent - d, 0.0, 1.0);

      // set point position as a mixture between the position + target
      vec3 pos = mix(pos0, pos1, smoothstep(0., 1., percent));
      vec4 world = modelViewMatrix * vec4(pos, 1.0);
      gl_Position = projectionMatrix * world;

      // use the unscaled point position and camera position to set point size
      float s = mix(scale, scaleTarget, percent);
      float pointSize = s / -world.z;

      if (selected > 0.5) {
        gl_PointSize = pointSize + (pointSize * borderWidth);
      } else {
        gl_PointSize = pointSize;
      }
    }

</script>

<script type='x-shader/x-fragment' id='fragment-shader'>
    /**
    * The fragment shader's main() function must define `gl_FragColor`,
    * which describes the pixel color of each pixel on the screen.
    *
    * To do so, we can use uniforms passed into the shader and varyings
    * passed from the vertex shader.
    *
    * Attempting to read a varying not generated by the vertex shader will
    * throw a warning but won't prevent shader compiling.
    **/

    #version 100
    #define SHADER_NAME instancedFragment
    #define SELECTING

    precision mediump float;

    uniform float useColor;
    uniform float cellAtlasPxPerSide;
    uniform float lodAtlasPxPerSide;
    uniform float cellPxHeight;
    uniform float lodPxHeight;
    uniform float borderWidth;
    uniform vec3 borderColor;

    varying vec3 vColor;         // cell's color (for gpu picking)
    varying vec2 vOffset;        // cell's offset in px from left, top of tex
    varying float vWidth;        // cell's width in lod tex in px
    varying float vHeight;       // cell's height in lod tex in px
    varying float vOpacity;      // cell's opacity
    varying float vSelected;     // cell's presence (>0.5) or absence (<0.5) from selection
    varying float vTextureIndex; // cell's texture index

    #ifndef SELECTING
      uniform sampler2D textures[N_TEXTURES]; // array of sampler2Ds
      uniform sampler2D lodTexture; // single sampler2D
    #endif

    void main() {
      // is this cell a LOD cell?
      bool isLod = vTextureIndex < -0.5;

      // get the width of the border on each side of the cell
      float borderW = borderWidth / 2.0;

      // find the width and height of this cell in its texture (in px)
      float w = isLod ? vWidth : vWidth/vHeight*cellPxHeight;
      float h = isLod ? vHeight : cellPxHeight;

      // find the length of the cell in its longest dimension (in px)
      float big = max(w, h);

      // set boolean indicating whether to center cells
      bool center = true;

      // find min, max vals of 0:1 scaled x axis to be textured
      float x0 = center ? (big-w)/2.0/big : 0.0;
      float x1 = center ? (w/big)+x0 : w / big;

      // find min, max vals of 0:1 scaled y axis to be textured
      float y0 = center ? (big-h)/2.0/big : 0.0;
      float y1 = center ? (h/big)+y0 : h / big;

      // clip the cell to center the texture on the x axis
      if (h > w && (gl_PointCoord.x < x0 || gl_PointCoord.x > x1)) discard;

      // if this cell's image is landscape clip bottom margin
      else if (w > h && gl_PointCoord.y < y0 || gl_PointCoord.y > y1) discard;

      // if this shader is using vColor attributes skip texture processing
      if (int(useColor) == 1) gl_FragColor = vec4(vColor, 1.0);

      // this cell should be textured
      else {

        // check if the current pointcoord position is within the border
        if (vSelected > 0.5 &&
           (gl_PointCoord.x < x0 + borderW ||
            gl_PointCoord.x > x1 - borderW ||
            gl_PointCoord.y < y0 + borderW ||
            gl_PointCoord.y > y1 - borderW)) {
          gl_FragColor = vec4(borderColor, 1.0);

        } else {

          // get the x and y positions to sample for this cell's texture
          float x = center ? gl_PointCoord.x - x0 : gl_PointCoord.x;
          float y = center ? gl_PointCoord.y - y0 : gl_PointCoord.y;

          // scale the x and y positions to the size of the texture
          vec2 uv = vOffset + vec2(x, y) * big;

          // set variables consumed by fragment tree below
          vec2 scaledUv = isLod ? uv/lodAtlasPxPerSide : uv/cellAtlasPxPerSide;
          int textureIndex = isLod ? -1 : int(vTextureIndex);

          // target to be replaced by texture tree
          TEXTURE_LOOKUP_TREE

          gl_FragColor = mix(gl_FragColor, vec4(0.0), 1.0-vOpacity);
          gl_FragColor.a = 1.0;

          if (vSelected > 0.5) gl_FragColor = mix(gl_FragColor, vec4(borderColor, 1.0), 0.15);
        }
      }
    }

</script>

<!-- Selection lasso -->
<script type='x-shader/x-vertex' id='dashed-vertex-shader'>
    precision mediump float;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform vec3 cameraPosition;

    attribute vec3 position;
    attribute float length;

    varying float vLength;

    void main() {
      vLength = length;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type='x-shader/x-fragment' id='dashed-fragment-shader'>
    precision mediump float;

    uniform vec3 cameraPosition;
    uniform bool render;
    uniform float time;

    varying float vLength;

    void main() {
      if (!render) discard;
      float dashSize = cameraPosition.z / 100.0;
      float gapSize = dashSize * 0.4;
      if (mod(vLength + time, dashSize + gapSize) > dashSize) discard;
      gl_FragColor = vec4(0.9, 0.9, 0.9, 1.0);
    }
</script>

<!-- Worker -->
<script type='script/worker' id='worker'>
    self.onmessage = function(event) {
      self.workerIndex = event.data.workerIndex;
      if (event.data.message == 'load') {
        self.url = event.data.url;
        self.get(self.url, self.onSuccess, self.onErr)
      }
    };

    self.onSuccess = function(data) {
      // window.caches is a global store of web worker data
      caches.open(self.url).then(function(cache) {
        return cache.add(data);
      })

      self.postMessage({
        status: 'complete',
        workerIndex: self.workerIndex,
        url: self.url,
      })
    }

    self.onErr = function() {
      self.postMessage({
        status: 'error',
        workerIndex: self.workerIndex,
      })
    }

    self.onProgress = function(e) {
      self.postMessage({
        status: 'progress',
        workerIndex: self.workerIndex,
        loadPercent: e.loaded/e.total,
      })
    }

    self.get = function(url, success, err) {
      var xmlhttp = new XMLHttpRequest();
      xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == XMLHttpRequest.DONE) {
          xmlhttp.status === 200
            ? success(xmlhttp.responseText)
            : err(xmlhttp);
        };
      };
      xmlhttp.onprogress = self.onProgress;
      xmlhttp.open('GET', url, true);
      xmlhttp.send();
    }

</script>

<!-- Header -->
<header id='header' class='no-highlight'>
    <a href='https://dhlab.yale.edu' target='_blank'>
        <img id='logo' src='assets/images/dhlab-logo.svg' alt='DHLab logo'/>
    </a>
    <div id='app-name'>PixPlot</div>
    <div class='tagline'>Avatar Synthesis</div>
    <div id='header-controls'>
        <div id='enable-manual-zoom'>
            <label for="enable-manual-zoom-input">Manual zoom</label>
            <input id='enable-manual-zoom-input' type='checkbox'/>
        </div>
        <div id='range-slider'>
            <label for="pointsize-range-input">Point Size</label>
            <input id='pointsize-range-input' min='0' max='0.03' value='0' step='0.00001' type='range'/>
        </div>
        <div id="chrono">
            <span id="chrono-time">0:00:00</span>
            <span id="chrono-controls">
            <a id="chrono-start-stop" href="#" onclick="chrono.start()"><i
                    class="fas fa-play-circle"></i></a>
            <a id="chrono-reset" href="#" onclick="chrono.reset()"><i class="fas fa-undo-alt"></i></a>
            <a id="chrono-done" href="#" onclick="chrono.doneDisplay()"><i class="fas fa-check-circle"></i></a>
          </span>
        </div>
    </div>
</header>
<div id='tooltip'></div>

<!-- Loader -->
<div id='loader-scene'>
    <p class='welcome'>You are about to start the experiment. Press "Enter" when loading is complete. You will be
        directed to a facial similarity map.</p>

    <div class='loader-container'>
        <div class='loader-icon'>
            <div class='blocks'>
                <div class='block'></div>
                <div class='block'></div>
                <div class='block'></div>
                <div class='block'></div>
                <div class='block'></div>
                <div class='block'></div>
                <div class='block'></div>
                <div class='block'></div>
                <div class='block'></div>
            </div>
        </div>
        <div id='loader-text'>
            <span id='progress'>0%</span>
        </div>
    </div>
    <button id='enter-button'>Enter</button>
</div>

<!-- Canvas -->
<div id='canvas-container'>
    <div id='canvas-target'>
        <canvas id='pixplot-canvas'/>
    </div>
</div>

<!-- Hotspot Navigation -->
<nav>
    <div id='nav-inner' class='no-highlight'>
        <h2>Hotspots</h2>
        <!-- div where the hotspots will be added -->
        <div id='hotspots'></div>
        <!-- template used to add hotspots to the div above -->
        <script type='text/html' id='hotspot-template'>
            <% _.forEach(hotspots, function(hotspot) { %>
            <div class='hotspot'>
                <% if (lassoEnabled) { %> <!-- TODO vérifier s'il faut passer cette variable en paramètre dans le template (dans tsne.js) -->
                <div class='remove-hotspot-x'>✕</div>
                <% } %>
                <img alt='<%= hotspot.img %>' src='data/thumbs/<%= hotspot.img %>'>
                <% if (lassoEnabled) { %>
                <div class='hotspot-label' contenteditable='true'><%= hotspot.label %></div>
                <% } else { %>
                <div class='hotspot-label'><%= hotspot.label %></div>
                <% } %>
            </div>
            <% }); %>
        </script>
    </div>
    <div id='hotspot-actions'>
        <div id='save-hotspots' class='button hotspot-button'>Save Hotspots</div>
        <div id='create-hotspot' class='no-highlight button hotspot-button'>Create Hotspot</div>
    </div>
</nav>

<!-- Selection Navigation -->
<aside>
    <div id='aside-inner' class='no-highlight'>
        <h2>Selections</h2>
        <!-- div where the selected images will be added -->
        <div id='selections'></div>
        <!-- template used to add selected images to the div above -->
        <script type='text/html' id='selection-template'>
            <% _.forEach(selections, function(selection) { %>
            <div class='selection'>
                <img alt='<%= selection.label %>' src='data/thumbs/<%= selection.name %>'>
                <div class='selection-label'><%= selection.label %></div>
            </div>
            <% }); %>
        </script>
    </div>
</aside>


<!-- Final image choice Modal -->
<div id='final-choice-images-modal'>
    <div class='modal-content'>
        <div class='modal-top'>
            <!-- template used to generate the modal content -->
            <script type='text/html' id='final-choice-images-template'>
                <div class='modal-top-content'>
                    <h2>Selected Images</h2>
                    <p>You have selected <b id='n-images-final-choice'><%- images.length %></b> image<% if(images.length > 1) { %>s<% } %></p>
                    <p>Please select the one that corresponds the most to your target</p>
                    <div id='final-choice-images-grid'>
                        <% _.forEach(images, function(image, idx) { %>
                        <div class='selected-image'>
                            <div data-index='<%- idx %>' data-image='<%- image.name %>' class='background-image'
                                 style='background-image: url("data/originals/<%- image.name %>");'></div>
                        </div>
                        <% }); %>
                    </div>
                </div>
            </script>
            <!-- div where the generated modal content will be added -->
            <div id='final-choice-images-target'></div>
        </div>
    </div>
</div>

<!-- Result Modal -->
<div id='result-modal'>
    <div class='modal-content'>
        <div class='modal-top'>
            <!-- template used to generate the modal content -->
            <script type='text/html' id='result-template'>
                <div class='modal-top-content'>
                    <h2>Your results</h2>
                    <ul>
                        <li>Your time is: <b><%- result.chrono %></b></li>
                        <li>You selected <b><%- result.images.length %></b> image<% if(result.images.length > 1) { %>s<% } %></li>
                        <li>Your final choice is <b><%- result.choice %></b></li>
                    </ul>
                    <% if(result.save.httpStatus == 200) { %>
                    <div class="success">
                        <p>
                            Your results were saved on our server with the ID <%- result.save.id %>.<br/>
                            Please proceed with the rest of the experiment.
                        </p>
                    </div>
                    <% } else { %>
                    <div class="error">
                        <p>
                            An error occurred, your results couldn't be saved on our server.<br/>
                            Please report your results in the post-test questionnaire.
                        </p>
                    </div>
                    <% } %>
                </div>
            </script>
            <!-- div where the generated modal content will be added -->
            <div id='result-target'></div>
        </div>
    </div>
</div>

<!-- Image Picker: single image selection (when the user clicks on an image in the canvas to add it to the selection) -->
<!-- template used to generate the modal content -->
<script type='text/html' id='selected-image-template'>
    <div class='modal-content'>
        <div class='modal-x'>✕</div>
        <div class='modal-top'>
            <div class='modal-top-content' id='selected-image-parent'>
                <div class='icons'>
                    <a id='mark-icon' href='#' onclick="selections.markImage('<%- meta.filename %>'); pickerModal.close();">
                        <i class="fas fa-check" style="color: black;"></i>
                    </a>
                </div>
            </div>
        </div>
    </div>
</script>
<!-- div where the generated modal content will be added -->
<div id='selected-image-target' class='no-highlight'></div>

<!-- Image Selection: multi-image selection -->
<div id='selection-icons' class='no-highlight'>
    <img id='pan' src='assets/images/icons/pan.svg' class='active'/>
    <img id='select' src='assets/images/icons/lasso.png' class=''/>
    <div id='select-tooltip'>
        <div id='select-tooltip-heading'>Selection Mode</div>
        <p>Lasso to select. Shift + click to edit selection.</p>
        <div id='select-tooltip-button'>Got it</div>
    </div>
</div>
<div id='view-selected-container'>
    <div id='selected-images-count' class='no-highlight'>
        <div id='selected-images-x'>✕</div>
        <div id='count-target'>0</div>
        <div>images selected</div>
    </div>
    <div id='view-selected' class='no-highlight button'>View Selected</div>
</div>
<div id='selected-images-modal'>
    <div class='modal-content'>
        <div class='modal-top'>
            <script type='text/html' id='selected-images-template'>
                <div class='modal-top-content'>
                    <h2>Selected Images</h2>
                    <p>You have selected <b id='n-images-selected'><%- images.length %></b> images</p>
                    <div id='selected-images-grid'>
                        <% _.forEach(images, function(image, idx) { %>
                        <div class='selected-image'>
                            <div data-index='<%- idx %>' data-image='<%- image %>' class='background-image'
                                 style='background-image: url("data/thumbs/<%- image %>");'></div>
                        </div>
                        <% }); %>
                    </div>
                </div>
            </script>
            <div id='selected-images-target'></div>
        </div>
    </div>
</div>

<!-- Manual zoom -->
<div id='manual-zoom' class='no-highlight'>
    <span id='zoom-in-button'>+</span>
    <span id='zoom-out-button'>-</span>
</div>

<!-- Webgl / Noscript Warnings -->
<div id='webgl-not-available'>
    <div class='browser-message'>
        Sorry, your browser is not able to load a WebGL scene currently. Please check your browser settings and try again.
    </div>
</div>
<noscript>
    <span class='browser-message'>Sorry, your browser is not able to load a WebGL scene currently. Please enable JavaScript and try again.</span>
</noscript>

<script type='text/javascript' src='assets/vendor/dist/three.min.js'></script>
<script type='text/javascript' src='assets/vendor/dist/lodash.min.js'></script>
<script type='text/javascript' src='assets/js/object-assign-polyfill.js'></script>
<script type='text/javascript' src='assets/vendor/dist/tweenlite.min.js'></script>
<script type='text/javascript' src='assets/vendor/dist/trackball-controls.min.js'></script>
<script type='text/javascript' src='assets/vendor/dist/stats.min.js'></script>
<script type='text/javascript' src='assets/vendor/dist/gunzip.min.js'></script>
<script type='text/javascript' src='assets/vendor/dist/papaparse.min.js'></script> <!-- TODO is this library useful? -->
<script type='text/javascript' src='assets/js/tsne.js'></script>
</body>
</html>
